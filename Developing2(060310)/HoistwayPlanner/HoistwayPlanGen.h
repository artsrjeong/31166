/* HoistwayPlanGen.h
 * Algorithms for generating hoistway plan
 */
#ifndef	_HPG_H
#define	_HPG_H

#include "hoistway_plan.h"
#include "timer.h"
#include "HoistwayPlannerDefs.h"

#define MAX_PLANS	16			// max number of plans to be evaluated
#define MAX_SEQUENCES 16		// max number of sequences to be generated by enumerative algorithm
#define MAX_STACK_SIZE	16		// max number of stack size in branching algorithms
/* 
 * The name Pocket is mainly defined for lower car. The sequence of stops of lower car can be divided into pockets, each
 * of which consists of two edge nodes and one center node. The center node defins the depth of the pocket
 * The same data structure can be used to represent lead node and recession nodes.
 * The center_node can be used to represent lead node. left_node and right_node are the two recession nodes. 
 */
class Pocket
{
public:
	PLAN_INDEX_T left_node;		// pointer to the left node of the pocket
	PLAN_INDEX_T right_node;		// pointer to the right node of the pocket
	PLAN_INDEX_T center_node;		// pointer to the center node of the pocket
//	FLOOR_T left_floor;			// The floor number of the left floor
//	FLOOR_T right_floor;		// The floor number of the right floor
//	FLOOR_T center_floor;		// The floor number of the center floor
	SHORT left_floor;			// The floor number of the left floor
	SHORT right_floor;		// The floor number of the right floor
	SHORT center_floor;		// The floor number of the center floor
	inline Pocket()			// constructor of Pocket
	{
		left_node = right_node = center_node = -1;
		left_floor = right_floor = center_floor = NO_FLOOR;
	};
	void print( FILE *output);	// print the content of the pocket
};

// separation table record
class STRecord
{
public:
	short current_floor;
	short the_other_floor;
};

// data structure requried for an enumerative instance
// Each instance contains a committed sequence and a set of hall calls
class EnumerativeInstance
{
public:
	StopSequence committed_sequence;		// committed sequence of the instance
	DestinationEntryCalls Hcalls;			// Unprocessed hall calls of the sequence
    PLAN_INDEX_T call_to_append;				// remember the next call to append, -1 means first call 
	PLAN_INDEX_T call_to_append_prev;			// previous call of call to append
	EnumerativeInstance()
	{
		committed_sequence.reset();
		Hcalls.reset();
		call_to_append = call_to_append_prev = -1;
	}
	EnumerativeInstance & operator = (EnumerativeInstance &other)
	{
		committed_sequence.copy(other.committed_sequence);
		Hcalls.copy(other.Hcalls);
		call_to_append = other.call_to_append;
		call_to_append_prev = other.call_to_append_prev;
		return *this;
	}
};

/* The data structure for enumerating asssignment of lead nodes to pockets
 * Each object of this class correspond to a full or partial assignment
 */
class LeadNodesAssignment
{
public:
	short assignments[MAX_STOP];				// assignment of node to pocket		
	int lead_nodes_assigned;					// number of lead nodes already assigned
	int last_assigned_pocket_index;				// the index of pocket last assigned
	LeadNodesAssignment()						// constructer
	{
		lead_nodes_assigned = last_assigned_pocket_index = 0;
	};
	void print(FILE *output, int size);			// print the assignment 
	LeadNodesAssignment & operator = (LeadNodesAssignment &other);
};
// hoistway plan algorithm 
class HoistwayPlanGen
{
private:
	void MakeUpSeparationFloorTable(int hwyID);
	int UpperHighest;                        // highest floor of upper car
	int UpperLowest;                         // lowest floor of upper car
	int LowerHighest;                        // highest floor of lower car
	int LowerLowest;                         // lowest floor of lower car

	STRecord *UpperSeparationTable;                // Minimum separation table for upper car
	STRecord *LowerSeparationTable;                // Minimum separation table for lower car
	// Pocket lead_nodes[MAX_STOP];					// lead nodes defined by the upper car sequence
	// Pocket pockets[MAX_STOP];						// pockets defined by the lower car sequence
	Timer timer;								// timer for recording elapsed CPU time
public:
	HoistwayPlanGen(){};
	HoistwayPlanGen(int UpperHighest,int UpperLowest,int LowerHighest,int LowerLowest,STRecord *upper_table, STRecord *lowertable);
	int MinimumSeparationFloor(int floor, STRecord *table);				// search and return minimum separation floor from the table 
	int Enumerative(StopSequence &committed,DestinationEntryCalls &assigned_calls, StopSequence *feasible_sequences, 
					DestinationEntryCalls *scheduled_calls, unsigned short car_capacity, CarState );
	PLAN_INDEX_T EnumerativeProp2(StopSequence &committed, DestinationEntryCalls &assigned_calls, FLOOR_T origin, unsigned short);				// proposition 2 for enumerative method
	int EnumerativeProp3(StopSequence &committed, DestinationEntryCalls &assigned_calls, unsigned short capacity);		// proposition 3 for enumerative method 
	void FeasibleRule4(StopSequence &committed, DestinationEntryCalls &assigned_calls, unsigned short capacity);             // feasible rule 4
	int FullCollective(StopSequence &committed, DestinationEntryCalls &assigned_calls, StopSequence &feasible_sequences, unsigned short car_capacity, CarState );
	int FindPocket(StopSequence &seq, Pocket *pocket, CarState &);			// find the pocket defined by a lower car sequence
	PLAN_INDEX_T FindNextEdgeNode(StopSequence &ss, PLAN_INDEX_T start, PLAN_INDEX_T &lowest );				// find the next edge node from start, return the node and lowest node if found
	int FindLeadNodes(StopSequence &seq, Pocket *lead_nodes);	// find the lead nodes defined by a upper car sequence
	// Enumerate all feasible ways of assigning lead nodes into pockets, return 0 if no feasible assignment can be found
	int EnumerateNodesAssignment(StopSequence &upper_sequence, StopSequence &lower_sequence, LeadNodesAssignment *assignments, 
								 Pocket *lead_nodes, Pocket *pockets, int total_nodes,int total_pockets);
	// Generate coordinated  plan base on the assignement 
	int GenerateHoistwayPlan(HoistwayPlan &feasible_plan, LeadNodesAssignment &lns, Pocket *lead_nodes,Pocket *pockets, 
					 int num_lead_nodes, int num_pockets, CarState &uCarState, CarState &lCarState);
	int GenCoordinatedPlan(StopSequence &upper_sequence, StopSequence &lower_sequence, DestinationEntryCalls &upper_calls,
						DestinationEntryCalls &lower_calls, HoistwayPlan feasible_plans[], CarState &, CarState &);
	// CSW: 050805 Generate best hoistway plan given two sequence
	int GetBestHoistwayPlan(StopSequence &upper_sequence, StopSequence &lower_sequence, DestinationEntryCalls &upper_calls,
						DestinationEntryCalls &lower_calls, HoistwayPlan &bestPlan,T_HPSCORE &bestScore, CarState &, CarState &, int, int);
	T_HPSCORE GetBestPlan(HoistwayPlan &plan,CallList &, CallList &, HoistwayInfo &,int hwy, CarInfo [], CarState&, CarState &); // CSW: added 050805
	T_HPSCORE GetBestPlanEnumerateSequence(HoistwayPlan &plan,CallList &, CallList &, HoistwayInfo &,int hwy, CarInfo [], CarState&, CarState &); // CSW: added 050916
//	void InitHoistwayPlanGen(int UpperHighest,int UpperLowest,int LowerHighest,int LowerLowest,STRecord *upper_table, STRecord *lowertable); // shs wrapping
	void InitHoistwayPlanGen(BuildingInfo &, HoistwayInfo &);
	T_HPSCORE generatePlan(int hwy, HoistwayInfo &, CarInfo[], CarState &, CarState &, CallList &, CallList &, HoistwayPlan &plan);
	void BuildCommittedSequence(StopSequence &committed,DestinationEntryCalls &calls, CallList &, CarState &);
	int ExtractWaitingCalls(DestinationEntryCalls &uncommitttedCalls,	CallList &upperCall);
	void CleanUpPrecedence(HoistwayPlan &plan);
	int countArrivedAtOrigin(DestinationEntryCalls committedCalls, FLOOR_T origin);
	void CheckPivot(HoistwayPlan &plan, CarState&, CarState &);
	int CheckCarState(CarState &upperState, CarState &lowerState);
	int CheckTSADelay(CarState &uCarState, CarState &lCarState, int uCarID, int lCarId,HoistwayPlan &plan);
	// CSW051112: Added to check parking information and add parking if necessary
	void CheckParking(int idLower, CarState & lCarState, int &nPockets, StopSequence &lowerSequence, Pocket *pockets,
					int idUpper, CarState &uCarState, int &nLeadNodes, StopSequence &upperSequence, Pocket *leadNodes);
};

#endif